{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"k8s-image-swapper Mirror images into your own registry and swap image references automatically. k8s-image-swapper is a mutating webhook for Kubernetes, downloading images into your own registry and pointing the images to that new location. It is an alternative to a docker pull-through proxy . The feature set was primarily designed with Amazon ECR in mind but may work with other registries. Benefits \u00b6 Using k8s-image-swapper will improve the overall availability, reliability, durability and resiliency of your Kubernetes cluster by keeping 3 rd -party images mirrored into your own registry. k8s-image-swapper will transparently consolidate all images into a single registry without the need to adjust manifests therefore reducing the impact of external registry failures, rate limiting, network issues, change or removal of images while reducing data traffic and therefore cost. TL;DR: Protect against: external registry failure ( quay.io outage ) image pull rate limiting ( docker.io rate limits ) accidental image changes removal of images Use in air-gaped environments without the need to change manifests Reduce NAT ingress traffic/cost How it works \u00b6","title":"Home"},{"location":"index.html#benefits","text":"Using k8s-image-swapper will improve the overall availability, reliability, durability and resiliency of your Kubernetes cluster by keeping 3 rd -party images mirrored into your own registry. k8s-image-swapper will transparently consolidate all images into a single registry without the need to adjust manifests therefore reducing the impact of external registry failures, rate limiting, network issues, change or removal of images while reducing data traffic and therefore cost. TL;DR: Protect against: external registry failure ( quay.io outage ) image pull rate limiting ( docker.io rate limits ) accidental image changes removal of images Use in air-gaped environments without the need to change manifests Reduce NAT ingress traffic/cost","title":"Benefits"},{"location":"index.html#how-it-works","text":"","title":"How it works"},{"location":"configuration.html","text":"Configuration \u00b6 The configuration is managed via the config file .k8s-image-swapper.yaml . Some options can be overriden via parameters, e.g. --dry-run . Dry Run \u00b6 The option dryRun allows to run the webhook without executing the actions, e.g. repository creation, image download and manifest mutation. Example dryRun : true Log Level & Format \u00b6 The option logLevel & logFormat allow to adjust the verbosity and format (e.g. json , console ). Example logLevel : debug logFormat : console ImageSwapPolicy \u00b6 The option imageSwapPolicy (default: exists ) defines the mutation strategy used. always : Will always swap the image regardless of the image existence in the target registry. This can result in pods ending in state ImagePullBack if images fail to be copied to the target registry. exists : Only swaps the image if it exits in the target registry. This can result in pods pulling images from the source registry, e.g. the first pod pulls from source registry, subsequent pods pull from target registry. ImageCopyPolicy \u00b6 The option imageCopyPolicy (default: delayed ) defines the image copy strategy used. delayed : Submits the copy job to a process queue and moves on. immediate : Submits the copy job to a process queue and waits for it to finish (deadline 8s). force : Attempts to immediately copy the image (deadline 8s). Source \u00b6 This section configures details about the image source. Filters \u00b6 Filters provide control over what pods will be processed. By default, all pods will be processed. If a condition matches, the pod will NOT be processed. JMESPath is used as query language and allows flexible rules for most use-cases. Info The data structure used for JMESPath is as follows: Structure obj : <Object Spec> container : <Container Spec> Example obj : metadata : name : static-web labels : role : myrole spec : containers : - name : web image : nginx ports : - name : web containerPort : 80 protocol : TCP container : name : web image : nginx ports : - name : web containerPort : 80 protocol : TCP Below you will find a list of common queries and/or ideas: List of common queries/ideas Do not process if namespace equals kube-system ( Helm chart default ) source : filters : - jmespath : \"obj.metadata.namespace == 'kube-system'\" Only process if namespace equals playground source : filters : - jmespath : \"obj.metadata.namespace != 'playground'\" Only process if namespace ends with -dev source : filters : - jmespath : \"ends_with(obj.metadata.namespace,'-dev')\" Do not process AWS ECR images source : filters : - jmespath : \"contains(container.image, '.dkr.ecr.') && contains(container.image, '.amazonaws.com')\" k8s-image-swapper will log the filter data and result in debug mode. This can be used in conjunction with JMESPath.org which has a live editor that can be used as a playground to experiment with more complex queries. Target \u00b6 This section configures details about the image target. AWS \u00b6 The option target.registry.aws holds details about the target registry storing the images. The AWS Account ID and Region is primarily used to construct the ECR domain [ACCOUNTID].dkr.ecr.[REGION].amazonaws.com . Example target : aws : accountId : 123456789 region : ap-southeast-2 ECR Options \u00b6 Tags \u00b6 This provides a way to add custom tags to newly created repositories. This may be useful while looking at AWS costs. It's a slice of Key and Value . Example target : type : aws aws : ecrOptions : tags : - name : cluster value : myCluster","title":"Configuration"},{"location":"configuration.html#configuration","text":"The configuration is managed via the config file .k8s-image-swapper.yaml . Some options can be overriden via parameters, e.g. --dry-run .","title":"Configuration"},{"location":"configuration.html#dry-run","text":"The option dryRun allows to run the webhook without executing the actions, e.g. repository creation, image download and manifest mutation. Example dryRun : true","title":"Dry Run"},{"location":"configuration.html#log-level-format","text":"The option logLevel & logFormat allow to adjust the verbosity and format (e.g. json , console ). Example logLevel : debug logFormat : console","title":"Log Level &amp; Format"},{"location":"configuration.html#imageswappolicy","text":"The option imageSwapPolicy (default: exists ) defines the mutation strategy used. always : Will always swap the image regardless of the image existence in the target registry. This can result in pods ending in state ImagePullBack if images fail to be copied to the target registry. exists : Only swaps the image if it exits in the target registry. This can result in pods pulling images from the source registry, e.g. the first pod pulls from source registry, subsequent pods pull from target registry.","title":"ImageSwapPolicy"},{"location":"configuration.html#imagecopypolicy","text":"The option imageCopyPolicy (default: delayed ) defines the image copy strategy used. delayed : Submits the copy job to a process queue and moves on. immediate : Submits the copy job to a process queue and waits for it to finish (deadline 8s). force : Attempts to immediately copy the image (deadline 8s).","title":"ImageCopyPolicy"},{"location":"configuration.html#source","text":"This section configures details about the image source.","title":"Source"},{"location":"configuration.html#filters","text":"Filters provide control over what pods will be processed. By default, all pods will be processed. If a condition matches, the pod will NOT be processed. JMESPath is used as query language and allows flexible rules for most use-cases. Info The data structure used for JMESPath is as follows: Structure obj : <Object Spec> container : <Container Spec> Example obj : metadata : name : static-web labels : role : myrole spec : containers : - name : web image : nginx ports : - name : web containerPort : 80 protocol : TCP container : name : web image : nginx ports : - name : web containerPort : 80 protocol : TCP Below you will find a list of common queries and/or ideas: List of common queries/ideas Do not process if namespace equals kube-system ( Helm chart default ) source : filters : - jmespath : \"obj.metadata.namespace == 'kube-system'\" Only process if namespace equals playground source : filters : - jmespath : \"obj.metadata.namespace != 'playground'\" Only process if namespace ends with -dev source : filters : - jmespath : \"ends_with(obj.metadata.namespace,'-dev')\" Do not process AWS ECR images source : filters : - jmespath : \"contains(container.image, '.dkr.ecr.') && contains(container.image, '.amazonaws.com')\" k8s-image-swapper will log the filter data and result in debug mode. This can be used in conjunction with JMESPath.org which has a live editor that can be used as a playground to experiment with more complex queries.","title":"Filters"},{"location":"configuration.html#target","text":"This section configures details about the image target.","title":"Target"},{"location":"configuration.html#aws","text":"The option target.registry.aws holds details about the target registry storing the images. The AWS Account ID and Region is primarily used to construct the ECR domain [ACCOUNTID].dkr.ecr.[REGION].amazonaws.com . Example target : aws : accountId : 123456789 region : ap-southeast-2","title":"AWS"},{"location":"configuration.html#ecr-options","text":"","title":"ECR Options"},{"location":"configuration.html#tags","text":"This provides a way to add custom tags to newly created repositories. This may be useful while looking at AWS costs. It's a slice of Key and Value . Example target : type : aws aws : ecrOptions : tags : - name : cluster value : myCluster","title":"Tags"},{"location":"faq.html","text":"FAQ \u00b6 Is pulling from private registries supported? \u00b6 Yes, imagePullSecrets on Pod and ServiceAccount level are supported. Are config changes reloaded gracefully? \u00b6 Not yet, they require a pod rotation. What happens if the image is not found in the target registry? \u00b6 Please see Configuration > ImageCopyPolicy . What level of registry outage does this handle? \u00b6 If the source image registry is not reachable it will replace the reference with the target registry reference. If the target registry is down it will do the same. It has no notion of the target registry being up or down. What happens if k8s-image-swapper is unavailable? \u00b6 Kubernetes will continue to work as if k8s-image-swapper was not installed. The webhook failure policy is set to Ignore . Tip Environments with strict compliance requirements (or air-gapped) may overwrite this with Fail to avoid falling back to the public images. Why are sidecar images not being replaced? \u00b6 A Kubernetes cluster can have multiple mutating webhooks. Mutating webhooks execute sequentiatlly and each can change a submitted object. Changes may be applied after k8s-image-swapper was executed, e.g. Istio injecting a sidecar. ... -> k8s-image-swapper -> Istio sidecar injection --> ... Kubernetes 1.15+ allows to re-run webhooks if a mutating webhook modifies an object. The behaviour is controlled by the Reinvocation policy . reinvocationPolicy may be set to Never or IfNeeded . It defaults to Never. Never : the webhook must not be called more than once in a single admission evaluation IfNeeded : the webhook may be called again as part of the admission evaluation if the object being admitted is modified by other admission plugins after the initial webhook call. The reinvocation policy can be set in the helm chart as follows: Helm Chart webhook : reinvocationPolicy : IfNeeded","title":"FAQ"},{"location":"faq.html#faq","text":"","title":"FAQ"},{"location":"faq.html#is-pulling-from-private-registries-supported","text":"Yes, imagePullSecrets on Pod and ServiceAccount level are supported.","title":"Is pulling from private registries supported?"},{"location":"faq.html#are-config-changes-reloaded-gracefully","text":"Not yet, they require a pod rotation.","title":"Are config changes reloaded gracefully?"},{"location":"faq.html#what-happens-if-the-image-is-not-found-in-the-target-registry","text":"Please see Configuration > ImageCopyPolicy .","title":"What happens if the image is not found in the target registry?"},{"location":"faq.html#what-level-of-registry-outage-does-this-handle","text":"If the source image registry is not reachable it will replace the reference with the target registry reference. If the target registry is down it will do the same. It has no notion of the target registry being up or down.","title":"What level of registry outage does this handle?"},{"location":"faq.html#what-happens-if-k8s-image-swapper-is-unavailable","text":"Kubernetes will continue to work as if k8s-image-swapper was not installed. The webhook failure policy is set to Ignore . Tip Environments with strict compliance requirements (or air-gapped) may overwrite this with Fail to avoid falling back to the public images.","title":"What happens if k8s-image-swapper is unavailable?"},{"location":"faq.html#why-are-sidecar-images-not-being-replaced","text":"A Kubernetes cluster can have multiple mutating webhooks. Mutating webhooks execute sequentiatlly and each can change a submitted object. Changes may be applied after k8s-image-swapper was executed, e.g. Istio injecting a sidecar. ... -> k8s-image-swapper -> Istio sidecar injection --> ... Kubernetes 1.15+ allows to re-run webhooks if a mutating webhook modifies an object. The behaviour is controlled by the Reinvocation policy . reinvocationPolicy may be set to Never or IfNeeded . It defaults to Never. Never : the webhook must not be called more than once in a single admission evaluation IfNeeded : the webhook may be called again as part of the admission evaluation if the object being admitted is modified by other admission plugins after the initial webhook call. The reinvocation policy can be set in the helm chart as follows: Helm Chart webhook : reinvocationPolicy : IfNeeded","title":"Why are sidecar images not being replaced?"},{"location":"getting-started.html","text":"Getting started \u00b6 This document will provide guidance for installing k8s-image-swapper . Prerequisites \u00b6 k8s-image-swapper will automatically create image repositories and mirror images into them. This requires certain permissions for your target registry ( only AWS ECR supported atm ). Before you get started choose a namespace to install k8s-image-swapper in, e.g. operations or k8s-image-swapper . Ensure the namespace exists and is configured as your current context 1 . All examples below will omit the namespace. AWS ECR as target registry \u00b6 AWS supports a variety of authentication strategies. k8s-image-swapper uses the official Amazon AWS SDK and therefore supports all available authentication strategies . Choose from one of the strategies below or an alternative if needed. IAM credentials \u00b6 Create an IAM user (e.g. k8s-image-swapper ) with permissions 2 to create ECR repositories and upload container images. An IAM policy example can be found in the footnotes 2 . Create a Kubernetes secret (e.g. k8s-image-swapper-aws ) containing the IAM credentials you just obtained, e.g. kubectl create secret generic k8s-image-swapper-aws \\ --from-literal = aws_access_key_id = <...> \\ --from-literal = aws_secret_access_key = <...> Using ECR registries cross-account \u00b6 Although ECR allows creating registry policy that allows reposistories creation from different account, there's no way to push anything to these repositories. ECR resource-level policy can not be applied during creation, and to apply it afterwards we need ecr:SetRepositoryPolicy permission, which foreign account doesn't have. One way out of this conundrum is to assume the role in target account target : type : aws aws : accountId : 123456789 region : ap-southeast-2 role : arn:aws:iam::123456789012:role/roleName Note Make sure that target role has proper trust permissions that allow to assume it cross-account Note In order te be able to pull images from outside accounts, you will have to apply proper access policy Access policy \u00b6 You can specify the access policy that will be applied to the created repos in config. Policy should be raw json string. For example: target : aws : accountId : 123456789 region : ap-southeast-2 role : arn:aws:iam::123456789012:role/roleName accessPolicy : '{ \"Statement\": [ { \"Sid\": \"AllowCrossAccountPull\", \"Effect\": \"Allow\", \"Principal\": { \"AWS\": \"*\" }, \"Action\": [ \"ecr:GetDownloadUrlForLayer\", \"ecr:BatchGetImage\", \"ecr:BatchCheckLayerAvailability\" ], \"Condition\": { \"StringEquals\": { \"aws:PrincipalOrgID\": \"o-xxxxxxxxxx\" } } } ], \"Version\": \"2008-10-17\" }' Lifecycle policy \u00b6 Similarly to access policy, lifecycle policy can be specified, for example: target : aws : accountId : 123456789 region : ap-southeast-2 role : arn:aws:iam::123456789012:role/roleName lifecyclePolicy : '{ \"rules\": [ { \"rulePriority\": 1, \"description\": \"Rule 1\", \"selection\": { \"tagStatus\": \"any\", \"countType\": \"imageCountMoreThan\", \"countNumber\": 1000 }, \"action\": { \"type\": \"expire\" } } ] } ' Service Account \u00b6 Create an Webidentity IAM role (e.g. k8s-image-swapper ) with the following trust policy, e.g { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Principal\": { \"Federated\": \"arn:aws:iam::${your_aws_account_id}:oidc-provider/${oidc_image_swapper_role_arn}\" }, \"Action\": \"sts:AssumeRoleWithWebIdentity\", \"Condition\": { \"StringEquals\": { \"${oidc_image_swapper_role_arn}:sub\": \"system:serviceaccount:${k8s_image_swapper_namespace}:${k8s_image_swapper_serviceaccount_name}\" } } } ] } Create and attach permission policy 2 to the role from Step 1.. Note: You can see a complete example below in Terraform Helm \u00b6 Add the Helm chart repository: helm repo add estahn https://estahn.github.io/charts/ Update the local chart information: helm repo update Install k8s-image-swapper helm install k8s-image-swapper estahn/k8s-image-swapper \\ --set config.target.aws.accountId=$AWS_ACCOUNT_ID \\ --set config.target.aws.region=$AWS_DEFAULT_REGION \\ --set awsSecretName=k8s-image-swapper-aws Note awsSecretName is not required for the Service Account method and instead the service account is annotated: serviceAccount : create : true annotations : eks.amazonaws.com/role-arn : ${oidc_image_swapper_role_arn} Terraform \u00b6 Full example of helm chart deployment with AWS service account setup. data \"aws_caller_identity\" \"current\" { } variable \"cluster_oidc_provider\" { default = \"oidc.eks.ap-southeast-1.amazonaws.com/id/ABCDEFGHIJKLMNOPQRSTUVWXYZ012345\" description = \"example oidc endpoint that is created during eks deployment\" } variable \"cluster_name\" { default = \"test\" description = \"name of the eks cluster being deployed to\" } variable \"region\" { default = \"ap-southeast-1\" description = \"name of the eks cluster being deployed to\" } variable \"k8s_image_swapper_namespace\" { default = \"kube-system\" description = \"namespace to install k8s-image-swapper\" } variable \"k8s_image_swapper_name\" { default = \"k8s-image-swapper\" description = \"name for k8s-image-swapper release and service account\" } #k8s-image-swapper helm chart resource \"helm_release\" \"k8s_image_swapper\" { name = var.k8s_image_swapper_name namespace = \"kube-system\" repository = \"https://estahn.github.io/charts/\" chart = \"k8s-image-swapper\" keyring = \"\" version = \"1.0.1\" values = [ <<YAML config: dryRun: true logLevel: debug logFormat: console source: # Filters provide control over what pods will be processed. # By default all pods will be processed. If a condition matches, the pod will NOT be processed. # For query language details see https://jmespath.org/ filters: - jmespath: \"obj.metadata.namespace != 'default'\" - jmespath: \"contains(container.image, '.dkr.ecr.') && contains(container.image, '.amazonaws.com')\" target: aws: accountId: \"${data.aws_caller_identity.current.account_id}\" region: ${var.region} secretReader: enabled: true serviceAccount: # Specifies whether a service account should be created create: true # Specifies annotations for this service account annotations: eks.amazonaws.com/role-arn: \"arn:aws:iam::${data.aws_caller_identity.current.account_id}:role/${aws_iam_role.k8s_image_swapper.name}\" YAML , ] } #iam policy for k8s-image-swapper service account resource \"aws_iam_role_policy\" \"k8s_image_swapper\" { name = \"${var.cluster_name}-${var.k8s_image_swapper_name}\" role = aws_iam_role.k8s_image_swapper.id policy = <<-EOF { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Sid\": \"\", \"Effect\": \"Allow\", \"Action\": [ \"ecr:GetAuthorizationToken\", \"ecr:DescribeRepositories\", \"ecr:DescribeRegistry\" ], \"Resource\": \"*\" }, { \"Sid\": \"\", \"Effect\": \"Allow\", \"Action\": [ \"ecr:UploadLayerPart\", \"ecr:PutImage\", \"ecr:ListImages\", \"ecr:InitiateLayerUpload\", \"ecr:GetDownloadUrlForLayer\", \"ecr:CreateRepository\", \"ecr:CompleteLayerUpload\", \"ecr:BatchGetImage\", \"ecr:BatchCheckLayerAvailability\" ], \"Resource\": [ \"arn:aws:ecr:*:${data.aws_caller_identity.current.account_id}:repository/docker.io/*\", \"arn:aws:ecr:*:${data.aws_caller_identity.current.account_id}:repository/quay.io/*\" ] } ] } EOF } #role for k8s-image-swapper service account resource \"aws_iam_role\" \"k8s_image_swapper\" { name = \"${var.cluster_name}-${var.k8s_image_swapper_name}\" assume_role_policy = <<-EOF { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Principal\": { \"Federated\": \"arn:aws:iam::${data.aws_caller_identity.current.account_id}:oidc-provider/${replace(var.cluster_oidc_provider, \"/https:///\", \"\")}\" }, \"Action\": \"sts:AssumeRoleWithWebIdentity\", \"Condition\": { \"StringEquals\": { \"${replace(var.cluster_oidc_provider, \"/https:///\", \"\")}:sub\": \"system:serviceaccount:${var.k8s_image_swapper_namespace}:${var.k8s_image_swapper_name}\" } } } ] } EOF } Use a tool like kubectx & kubens for convienience. \u21a9 IAM Policy { \"Version\" : \"2012-10-17\" , \"Statement\" : [ { \"Sid\" : \"\" , \"Effect\" : \"Allow\" , \"Action\" : [ \"ecr:GetAuthorizationToken\" , \"ecr:DescribeRepositories\" , \"ecr:DescribeRegistry\" ], \"Resource\" : \"*\" }, { \"Sid\" : \"\" , \"Effect\" : \"Allow\" , \"Action\" : [ \"ecr:UploadLayerPart\" , \"ecr:PutImage\" , \"ecr:ListImages\" , \"ecr:InitiateLayerUpload\" , \"ecr:GetDownloadUrlForLayer\" , \"ecr:CreateRepository\" , \"ecr:CompleteLayerUpload\" , \"ecr:BatchGetImage\" , \"ecr:BatchCheckLayerAvailability\" ], \"Resource\" : \"arn:aws:ecr:*:123456789:repository/*\" } ] } Further restricting access The resource configuration allows access to all AWS ECR repositories within the account 123456789. Restrict this further by repository name or tag. k8s-image-swapper will create repositories with the source registry as prefix, e.g. nginx \u2192 docker.io/library/nginx:latest . \u21a9 \u21a9 \u21a9","title":"Getting started"},{"location":"getting-started.html#getting-started","text":"This document will provide guidance for installing k8s-image-swapper .","title":"Getting started"},{"location":"getting-started.html#prerequisites","text":"k8s-image-swapper will automatically create image repositories and mirror images into them. This requires certain permissions for your target registry ( only AWS ECR supported atm ). Before you get started choose a namespace to install k8s-image-swapper in, e.g. operations or k8s-image-swapper . Ensure the namespace exists and is configured as your current context 1 . All examples below will omit the namespace.","title":"Prerequisites"},{"location":"getting-started.html#aws-ecr-as-target-registry","text":"AWS supports a variety of authentication strategies. k8s-image-swapper uses the official Amazon AWS SDK and therefore supports all available authentication strategies . Choose from one of the strategies below or an alternative if needed.","title":"AWS ECR as target registry"},{"location":"getting-started.html#iam-credentials","text":"Create an IAM user (e.g. k8s-image-swapper ) with permissions 2 to create ECR repositories and upload container images. An IAM policy example can be found in the footnotes 2 . Create a Kubernetes secret (e.g. k8s-image-swapper-aws ) containing the IAM credentials you just obtained, e.g. kubectl create secret generic k8s-image-swapper-aws \\ --from-literal = aws_access_key_id = <...> \\ --from-literal = aws_secret_access_key = <...>","title":"IAM credentials"},{"location":"getting-started.html#using-ecr-registries-cross-account","text":"Although ECR allows creating registry policy that allows reposistories creation from different account, there's no way to push anything to these repositories. ECR resource-level policy can not be applied during creation, and to apply it afterwards we need ecr:SetRepositoryPolicy permission, which foreign account doesn't have. One way out of this conundrum is to assume the role in target account target : type : aws aws : accountId : 123456789 region : ap-southeast-2 role : arn:aws:iam::123456789012:role/roleName Note Make sure that target role has proper trust permissions that allow to assume it cross-account Note In order te be able to pull images from outside accounts, you will have to apply proper access policy","title":"Using ECR registries cross-account"},{"location":"getting-started.html#access-policy","text":"You can specify the access policy that will be applied to the created repos in config. Policy should be raw json string. For example: target : aws : accountId : 123456789 region : ap-southeast-2 role : arn:aws:iam::123456789012:role/roleName accessPolicy : '{ \"Statement\": [ { \"Sid\": \"AllowCrossAccountPull\", \"Effect\": \"Allow\", \"Principal\": { \"AWS\": \"*\" }, \"Action\": [ \"ecr:GetDownloadUrlForLayer\", \"ecr:BatchGetImage\", \"ecr:BatchCheckLayerAvailability\" ], \"Condition\": { \"StringEquals\": { \"aws:PrincipalOrgID\": \"o-xxxxxxxxxx\" } } } ], \"Version\": \"2008-10-17\" }'","title":"Access policy"},{"location":"getting-started.html#lifecycle-policy","text":"Similarly to access policy, lifecycle policy can be specified, for example: target : aws : accountId : 123456789 region : ap-southeast-2 role : arn:aws:iam::123456789012:role/roleName lifecyclePolicy : '{ \"rules\": [ { \"rulePriority\": 1, \"description\": \"Rule 1\", \"selection\": { \"tagStatus\": \"any\", \"countType\": \"imageCountMoreThan\", \"countNumber\": 1000 }, \"action\": { \"type\": \"expire\" } } ] } '","title":"Lifecycle policy"},{"location":"getting-started.html#service-account","text":"Create an Webidentity IAM role (e.g. k8s-image-swapper ) with the following trust policy, e.g { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Principal\": { \"Federated\": \"arn:aws:iam::${your_aws_account_id}:oidc-provider/${oidc_image_swapper_role_arn}\" }, \"Action\": \"sts:AssumeRoleWithWebIdentity\", \"Condition\": { \"StringEquals\": { \"${oidc_image_swapper_role_arn}:sub\": \"system:serviceaccount:${k8s_image_swapper_namespace}:${k8s_image_swapper_serviceaccount_name}\" } } } ] } Create and attach permission policy 2 to the role from Step 1.. Note: You can see a complete example below in Terraform","title":"Service Account"},{"location":"getting-started.html#helm","text":"Add the Helm chart repository: helm repo add estahn https://estahn.github.io/charts/ Update the local chart information: helm repo update Install k8s-image-swapper helm install k8s-image-swapper estahn/k8s-image-swapper \\ --set config.target.aws.accountId=$AWS_ACCOUNT_ID \\ --set config.target.aws.region=$AWS_DEFAULT_REGION \\ --set awsSecretName=k8s-image-swapper-aws Note awsSecretName is not required for the Service Account method and instead the service account is annotated: serviceAccount : create : true annotations : eks.amazonaws.com/role-arn : ${oidc_image_swapper_role_arn}","title":"Helm"},{"location":"getting-started.html#terraform","text":"Full example of helm chart deployment with AWS service account setup. data \"aws_caller_identity\" \"current\" { } variable \"cluster_oidc_provider\" { default = \"oidc.eks.ap-southeast-1.amazonaws.com/id/ABCDEFGHIJKLMNOPQRSTUVWXYZ012345\" description = \"example oidc endpoint that is created during eks deployment\" } variable \"cluster_name\" { default = \"test\" description = \"name of the eks cluster being deployed to\" } variable \"region\" { default = \"ap-southeast-1\" description = \"name of the eks cluster being deployed to\" } variable \"k8s_image_swapper_namespace\" { default = \"kube-system\" description = \"namespace to install k8s-image-swapper\" } variable \"k8s_image_swapper_name\" { default = \"k8s-image-swapper\" description = \"name for k8s-image-swapper release and service account\" } #k8s-image-swapper helm chart resource \"helm_release\" \"k8s_image_swapper\" { name = var.k8s_image_swapper_name namespace = \"kube-system\" repository = \"https://estahn.github.io/charts/\" chart = \"k8s-image-swapper\" keyring = \"\" version = \"1.0.1\" values = [ <<YAML config: dryRun: true logLevel: debug logFormat: console source: # Filters provide control over what pods will be processed. # By default all pods will be processed. If a condition matches, the pod will NOT be processed. # For query language details see https://jmespath.org/ filters: - jmespath: \"obj.metadata.namespace != 'default'\" - jmespath: \"contains(container.image, '.dkr.ecr.') && contains(container.image, '.amazonaws.com')\" target: aws: accountId: \"${data.aws_caller_identity.current.account_id}\" region: ${var.region} secretReader: enabled: true serviceAccount: # Specifies whether a service account should be created create: true # Specifies annotations for this service account annotations: eks.amazonaws.com/role-arn: \"arn:aws:iam::${data.aws_caller_identity.current.account_id}:role/${aws_iam_role.k8s_image_swapper.name}\" YAML , ] } #iam policy for k8s-image-swapper service account resource \"aws_iam_role_policy\" \"k8s_image_swapper\" { name = \"${var.cluster_name}-${var.k8s_image_swapper_name}\" role = aws_iam_role.k8s_image_swapper.id policy = <<-EOF { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Sid\": \"\", \"Effect\": \"Allow\", \"Action\": [ \"ecr:GetAuthorizationToken\", \"ecr:DescribeRepositories\", \"ecr:DescribeRegistry\" ], \"Resource\": \"*\" }, { \"Sid\": \"\", \"Effect\": \"Allow\", \"Action\": [ \"ecr:UploadLayerPart\", \"ecr:PutImage\", \"ecr:ListImages\", \"ecr:InitiateLayerUpload\", \"ecr:GetDownloadUrlForLayer\", \"ecr:CreateRepository\", \"ecr:CompleteLayerUpload\", \"ecr:BatchGetImage\", \"ecr:BatchCheckLayerAvailability\" ], \"Resource\": [ \"arn:aws:ecr:*:${data.aws_caller_identity.current.account_id}:repository/docker.io/*\", \"arn:aws:ecr:*:${data.aws_caller_identity.current.account_id}:repository/quay.io/*\" ] } ] } EOF } #role for k8s-image-swapper service account resource \"aws_iam_role\" \"k8s_image_swapper\" { name = \"${var.cluster_name}-${var.k8s_image_swapper_name}\" assume_role_policy = <<-EOF { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Principal\": { \"Federated\": \"arn:aws:iam::${data.aws_caller_identity.current.account_id}:oidc-provider/${replace(var.cluster_oidc_provider, \"/https:///\", \"\")}\" }, \"Action\": \"sts:AssumeRoleWithWebIdentity\", \"Condition\": { \"StringEquals\": { \"${replace(var.cluster_oidc_provider, \"/https:///\", \"\")}:sub\": \"system:serviceaccount:${var.k8s_image_swapper_namespace}:${var.k8s_image_swapper_name}\" } } } ] } EOF } Use a tool like kubectx & kubens for convienience. \u21a9 IAM Policy { \"Version\" : \"2012-10-17\" , \"Statement\" : [ { \"Sid\" : \"\" , \"Effect\" : \"Allow\" , \"Action\" : [ \"ecr:GetAuthorizationToken\" , \"ecr:DescribeRepositories\" , \"ecr:DescribeRegistry\" ], \"Resource\" : \"*\" }, { \"Sid\" : \"\" , \"Effect\" : \"Allow\" , \"Action\" : [ \"ecr:UploadLayerPart\" , \"ecr:PutImage\" , \"ecr:ListImages\" , \"ecr:InitiateLayerUpload\" , \"ecr:GetDownloadUrlForLayer\" , \"ecr:CreateRepository\" , \"ecr:CompleteLayerUpload\" , \"ecr:BatchGetImage\" , \"ecr:BatchCheckLayerAvailability\" ], \"Resource\" : \"arn:aws:ecr:*:123456789:repository/*\" } ] } Further restricting access The resource configuration allows access to all AWS ECR repositories within the account 123456789. Restrict this further by repository name or tag. k8s-image-swapper will create repositories with the source registry as prefix, e.g. nginx \u2192 docker.io/library/nginx:latest . \u21a9 \u21a9 \u21a9","title":"Terraform"}]}