{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":"<p> k8s-image-swapper <p>Mirror images into your own registry and swap image references automatically.</p> </p> <p><code>k8s-image-swapper</code> is a mutating webhook for Kubernetes, downloading images into your own registry and pointing the images to that new location. It is an alternative to a docker pull-through proxy. The feature set was primarily designed with Amazon ECR in mind but may work with other registries.</p>"},{"location":"index.html#benefits","title":"Benefits","text":"<p>Using <code>k8s-image-swapper</code> will improve the overall availability, reliability, durability and resiliency of your Kubernetes cluster by keeping 3rd-party images mirrored into your own registry.</p> <p><code>k8s-image-swapper</code> will transparently consolidate all images into a single registry without the need to adjust manifests therefore reducing the impact of external registry failures, rate limiting, network issues, change or removal of images while reducing data traffic and therefore cost.</p> <p>TL;DR:</p> <ul> <li>Protect against:<ul> <li>external registry failure (quay.io outage)</li> <li>image pull rate limiting (docker.io rate limits)</li> <li>accidental image changes</li> <li>removal of images</li> </ul> </li> <li>Use in air-gaped environments without the need to change manifests</li> <li>Reduce NAT ingress traffic/cost</li> </ul>"},{"location":"index.html#how-it-works","title":"How it works","text":""},{"location":"configuration.html","title":"Configuration","text":"<p>The configuration is managed via the config file <code>.k8s-image-swapper.yaml</code>. Some options can be overriden via parameters, e.g. <code>--dry-run</code>.</p>"},{"location":"configuration.html#dry-run","title":"Dry Run","text":"<p>The option <code>dryRun</code> allows to run the webhook without executing the actions, e.g. repository creation, image download and manifest mutation.</p> <p>Example</p> <pre><code>dryRun: true\n</code></pre>"},{"location":"configuration.html#log-level-format","title":"Log Level &amp; Format","text":"<p>The option <code>logLevel</code> &amp; <code>logFormat</code> allow to adjust the verbosity and format (e.g. <code>json</code>, <code>console</code>).</p> <p>Example</p> <pre><code>logLevel: debug\nlogFormat: console\n</code></pre>"},{"location":"configuration.html#imageswappolicy","title":"ImageSwapPolicy","text":"<p>The option <code>imageSwapPolicy</code> (default: <code>exists</code>) defines the mutation strategy used.</p> <ul> <li><code>always</code>: Will always swap the image regardless of the image existence in the target registry.             This can result in pods ending in state ImagePullBack if images fail to be copied to the target registry.</li> <li><code>exists</code>: Only swaps the image if it exits in the target registry.             This can result in pods pulling images from the source registry, e.g. the first pod pulls             from source registry, subsequent pods pull from target registry.</li> </ul>"},{"location":"configuration.html#imagecopypolicy","title":"ImageCopyPolicy","text":"<p>The option <code>imageCopyPolicy</code> (default: <code>delayed</code>) defines the image copy strategy used.</p> <ul> <li><code>delayed</code>: Submits the copy job to a process queue and moves on.</li> <li><code>immediate</code>: Submits the copy job to a process queue and waits for it to finish (deadline 8s).</li> <li><code>force</code>: Attempts to immediately copy the image (deadline 8s).</li> </ul>"},{"location":"configuration.html#source","title":"Source","text":"<p>This section configures details about the image source.</p>"},{"location":"configuration.html#filters","title":"Filters","text":"<p>Filters provide control over what pods will be processed. By default, all pods will be processed. If a condition matches, the pod will NOT be processed.</p> <p>JMESPath is used as query language and allows flexible rules for most use-cases.</p> <p>Info</p> <p>The data structure used for JMESPath is as follows:</p> Structure <pre><code>obj:\n&lt;Object Spec&gt;\ncontainer:\n&lt;Container Spec&gt;\n</code></pre> Example <pre><code>obj:\nmetadata:\nname: static-web\nlabels:\nrole: myrole\nspec:\ncontainers:\n- name: web\nimage: nginx\nports:\n- name: web\ncontainerPort: 80\nprotocol: TCP\ncontainer:\nname: web\nimage: nginx\nports:\n- name: web\ncontainerPort: 80\nprotocol: TCP\n</code></pre> <p>Below you will find a list of common queries and/or ideas:</p> <p>List of common queries/ideas</p> <ul> <li>Do not process if namespace equals <code>kube-system</code> (Helm chart default)   <pre><code>source:\nfilters:\n- jmespath: \"obj.metadata.namespace == 'kube-system'\"\n</code></pre></li> <li>Only process if namespace equals <code>playground</code> <pre><code>source:\nfilters:\n- jmespath: \"obj.metadata.namespace != 'playground'\"\n</code></pre></li> <li>Only process if namespace ends with <code>-dev</code> <pre><code>source:\nfilters:\n- jmespath: \"ends_with(obj.metadata.namespace,'-dev')\"\n</code></pre></li> <li>Do not process AWS ECR images   <pre><code>source:\nfilters:\n- jmespath: \"contains(container.image, '.dkr.ecr.') &amp;&amp; contains(container.image, '.amazonaws.com')\"\n</code></pre></li> </ul> <p><code>k8s-image-swapper</code> will log the filter data and result in <code>debug</code> mode. This can be used in conjunction with JMESPath.org which has a live editor that can be used as a playground to experiment with more complex queries.</p>"},{"location":"configuration.html#target","title":"Target","text":"<p>This section configures details about the image target.</p>"},{"location":"configuration.html#aws","title":"AWS","text":"<p>The option <code>target.registry.aws</code> holds details about the target registry storing the images. The AWS Account ID and Region is primarily used to construct the ECR domain <code>[ACCOUNTID].dkr.ecr.[REGION].amazonaws.com</code>.</p> <p>Example</p> <pre><code>target:\naws:\naccountId: 123456789\nregion: ap-southeast-2\n</code></pre>"},{"location":"configuration.html#ecr-options","title":"ECR Options","text":""},{"location":"configuration.html#tags","title":"Tags","text":"<p>This provides a way to add custom tags to newly created repositories. This may be useful while looking at AWS costs. It's a slice of <code>Key</code> and <code>Value</code>.</p> <p>Example</p> <pre><code>target:\ntype: aws\naws:\necrOptions:\ntags:\n- key: cluster\nvalue: myCluster\n</code></pre>"},{"location":"faq.html","title":"FAQ","text":""},{"location":"faq.html#is-pulling-from-private-registries-supported","title":"Is pulling from private registries supported?","text":"<p>Yes, <code>imagePullSecrets</code> on <code>Pod</code> and <code>ServiceAccount</code> level are supported.</p>"},{"location":"faq.html#are-config-changes-reloaded-gracefully","title":"Are config changes reloaded gracefully?","text":"<p>Not yet, they require a pod rotation.</p>"},{"location":"faq.html#what-happens-if-the-image-is-not-found-in-the-target-registry","title":"What happens if the image is not found in the target registry?","text":"<p>Please see Configuration &gt; ImageCopyPolicy.</p>"},{"location":"faq.html#what-level-of-registry-outage-does-this-handle","title":"What level of registry outage does this handle?","text":"<p>If the source image registry is not reachable it will replace the reference with the target registry reference. If the target registry is down it will do the same. It has no notion of the target registry being up or down.</p>"},{"location":"faq.html#what-happens-if-k8s-image-swapper-is-unavailable","title":"What happens if <code>k8s-image-swapper</code> is unavailable?","text":"<p>Kubernetes will continue to work as if <code>k8s-image-swapper</code> was not installed. The webhook failure policy is set to <code>Ignore</code>.</p> <p>Tip</p> <p>Environments with strict compliance requirements (or air-gapped) may overwrite this with <code>Fail</code> to avoid falling back to the public images.</p>"},{"location":"faq.html#why-are-sidecar-images-not-being-replaced","title":"Why are sidecar images not being replaced?","text":"<p>A Kubernetes cluster can have multiple mutating webhooks. Mutating webhooks execute sequentiatlly and each can change a submitted object. Changes may be applied after <code>k8s-image-swapper</code> was executed, e.g. Istio injecting a sidecar.</p> <pre><code>... -&gt; k8s-image-swapper -&gt; Istio sidecar injection --&gt; ...\n</code></pre> <p>Kubernetes 1.15+ allows to re-run webhooks if a mutating webhook modifies an object. The behaviour is controlled by the Reinvocation policy.</p> <p>reinvocationPolicy may be set to <code>Never</code> or <code>IfNeeded</code>. It defaults to Never.</p> <ul> <li><code>Never</code>: the webhook must not be called more than once in a single admission evaluation</li> <li><code>IfNeeded</code>: the webhook may be called again as part of the admission evaluation if the object being admitted is modified by other admission plugins after the initial webhook call.</li> </ul> <p>The reinvocation policy can be set in the helm chart as follows:</p> <p>Helm Chart</p> <pre><code>webhook:\nreinvocationPolicy: IfNeeded\n</code></pre>"},{"location":"getting-started.html","title":"Getting started","text":"<p>This document will provide guidance for installing <code>k8s-image-swapper</code>.</p>"},{"location":"getting-started.html#prerequisites","title":"Prerequisites","text":"<p><code>k8s-image-swapper</code> will automatically create image repositories and mirror images into them. This requires certain permissions for your target registry (only AWS ECR supported atm).</p> <p>Before you get started choose a namespace to install <code>k8s-image-swapper</code> in, e.g. <code>operations</code> or <code>k8s-image-swapper</code>. Ensure the namespace exists and is configured as your current context1. All examples below will omit the namespace.</p>"},{"location":"getting-started.html#aws-ecr-as-target-registry","title":"AWS ECR as target registry","text":"<p>AWS supports a variety of authentication strategies. <code>k8s-image-swapper</code> uses the official Amazon AWS SDK and therefore supports all available authentication strategies. Choose from one of the strategies below or an alternative if needed.</p>"},{"location":"getting-started.html#iam-credentials","title":"IAM credentials","text":"<ol> <li>Create an IAM user (e.g. <code>k8s-image-swapper</code>) with permissions2 to create ECR repositories and upload container images.    An IAM policy example can be found in the footnotes2.</li> <li> <p>Create a Kubernetes secret (e.g. <code>k8s-image-swapper-aws</code>) containing the IAM credentials you just obtained, e.g.</p> <pre><code>kubectl create secret generic k8s-image-swapper-aws \\\n--from-literal=aws_access_key_id=&lt;...&gt; \\\n--from-literal=aws_secret_access_key=&lt;...&gt;\n</code></pre> </li> </ol>"},{"location":"getting-started.html#using-ecr-registries-cross-account","title":"Using ECR registries cross-account","text":"<p>Although ECR allows creating registry policy that allows reposistories creation from different account, there's no way to push anything to these repositories. ECR resource-level policy can not be applied during creation, and to apply it afterwards we need ecr:SetRepositoryPolicy permission, which foreign account doesn't have.</p> <p>One way out of this conundrum is to assume the role in target account</p> <pre><code>target:\ntype: aws\naws:\naccountId: 123456789\nregion: ap-southeast-2\nrole: arn:aws:iam::123456789012:role/roleName\n</code></pre> <p>Note</p> <p>Make sure that target role has proper trust permissions that allow to assume it cross-account</p> <p>Note</p> <p>In order te be able to pull images from outside accounts, you will have to apply proper access policy</p>"},{"location":"getting-started.html#access-policy","title":"Access policy","text":"<p>You can specify the access policy that will be applied to the created repos in config. Policy should be raw json string. For example: <pre><code>target:\naws:\naccountId: 123456789\nregion: ap-southeast-2\nrole: arn:aws:iam::123456789012:role/roleName\naccessPolicy: '{\n\"Statement\": [\n{\n\"Sid\": \"AllowCrossAccountPull\",\n\"Effect\": \"Allow\",\n\"Principal\": {\n\"AWS\": \"*\"\n},\n\"Action\": [\n\"ecr:GetDownloadUrlForLayer\",\n\"ecr:BatchGetImage\",\n\"ecr:BatchCheckLayerAvailability\"\n],\n\"Condition\": {\n\"StringEquals\": {\n\"aws:PrincipalOrgID\": \"o-xxxxxxxxxx\"\n}\n}\n}\n],\n\"Version\": \"2008-10-17\"\n}'\n</code></pre></p>"},{"location":"getting-started.html#lifecycle-policy","title":"Lifecycle policy","text":"<p>Similarly to access policy, lifecycle policy can be specified, for example:</p> <pre><code>target:\naws:\naccountId: 123456789\nregion: ap-southeast-2\nrole: arn:aws:iam::123456789012:role/roleName\nlifecyclePolicy: '{\n\"rules\": [\n{\n\"rulePriority\": 1,\n\"description\": \"Rule 1\",\n\"selection\": {\n\"tagStatus\": \"any\",\n\"countType\": \"imageCountMoreThan\",\n\"countNumber\": 1000\n},\n\"action\": {\n\"type\": \"expire\"\n}\n}\n]\n}\n'\n</code></pre>"},{"location":"getting-started.html#service-account","title":"Service Account","text":"<ol> <li> <p>Create an Webidentity IAM role (e.g. <code>k8s-image-swapper</code>) with the following trust policy, e.g <pre><code>{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"Federated\": \"arn:aws:iam::${your_aws_account_id}:oidc-provider/${oidc_image_swapper_role_arn}\"\n      },\n      \"Action\": \"sts:AssumeRoleWithWebIdentity\",\n      \"Condition\": {\n        \"StringEquals\": {\n          \"${oidc_image_swapper_role_arn}:sub\": \"system:serviceaccount:${k8s_image_swapper_namespace}:${k8s_image_swapper_serviceaccount_name}\"\n        }\n      }\n    }\n  ]\n}\n</code></pre></p> </li> <li> <p>Create and attach permission policy2 to the role from Step 1..</p> </li> </ol> <p>Note: You can see a complete example below in Terraform</p>"},{"location":"getting-started.html#helm","title":"Helm","text":"<ol> <li>Add the Helm chart repository:    <pre><code>helm repo add estahn https://estahn.github.io/charts/\n</code></pre></li> <li>Update the local chart information:    <pre><code>helm repo update\n</code></pre></li> <li>Install <code>k8s-image-swapper</code> <pre><code>helm install k8s-image-swapper estahn/k8s-image-swapper \\\n  --set config.target.aws.accountId=$AWS_ACCOUNT_ID \\\n  --set config.target.aws.region=$AWS_DEFAULT_REGION \\\n  --set awsSecretName=k8s-image-swapper-aws\n</code></pre></li> </ol> <p>Note</p> <p><code>awsSecretName</code> is not required for the Service Account method and instead the service account is annotated: <pre><code>serviceAccount:\ncreate: true\nannotations:\neks.amazonaws.com/role-arn: ${oidc_image_swapper_role_arn}\n</code></pre></p>"},{"location":"getting-started.html#terraform","title":"Terraform","text":"<ul> <li>Full example of helm chart deployment with AWS service account setup.</li> </ul> <pre><code>data \"aws_caller_identity\" \"current\" {\n}\n\nvariable \"cluster_oidc_provider\" {\n  default = \"oidc.eks.ap-southeast-1.amazonaws.com/id/ABCDEFGHIJKLMNOPQRSTUVWXYZ012345\"\n  description = \"example oidc endpoint that is created during eks deployment\"\n}\n\nvariable  \"cluster_name\" {\n  default = \"test\"\n  description = \"name of the eks cluster being deployed to\"\n}\n\n\nvariable  \"region\" {\n  default = \"ap-southeast-1\"\n  description = \"name of the eks cluster being deployed to\"\n}\n\nvariable \"k8s_image_swapper_namespace\" {\n  default     = \"kube-system\"\n  description = \"namespace to install k8s-image-swapper\"\n}\n\nvariable \"k8s_image_swapper_name\" {\n  default     = \"k8s-image-swapper\"\n  description = \"name for k8s-image-swapper release and service account\"\n}\n\n#k8s-image-swapper helm chart\nresource \"helm_release\" \"k8s_image_swapper\" {\n  name       = var.k8s_image_swapper_name\n  namespace  = \"kube-system\"\n  repository = \"https://estahn.github.io/charts/\"\n  chart   = \"k8s-image-swapper\"\n  keyring = \"\"\n  version = \"1.0.1\"\n  values = [\n    &lt;&lt;YAML\nconfig:\n  dryRun: true\n  logLevel: debug\n  logFormat: console\n\n  source:\n    # Filters provide control over what pods will be processed.\n    # By default all pods will be processed. If a condition matches, the pod will NOT be processed.\n    # For query language details see https://jmespath.org/\n    filters:\n      - jmespath: \"obj.metadata.namespace != 'default'\"\n      - jmespath: \"contains(container.image, '.dkr.ecr.') &amp;&amp; contains(container.image, '.amazonaws.com')\"\n  target:\n    aws:\n      accountId: \"${data.aws_caller_identity.current.account_id}\"\n      region: ${var.region}\n\nsecretReader:\n  enabled: true\n\nserviceAccount:\n  # Specifies whether a service account should be created\n  create: true\n  # Specifies annotations for this service account\n  annotations:\n    eks.amazonaws.com/role-arn: \"arn:aws:iam::${data.aws_caller_identity.current.account_id}:role/${aws_iam_role.k8s_image_swapper.name}\"\nYAML\n    ,\n  ]\n}\n\n#iam policy for k8s-image-swapper service account\nresource \"aws_iam_role_policy\" \"k8s_image_swapper\" {\n  name = \"${var.cluster_name}-${var.k8s_image_swapper_name}\"\n  role = aws_iam_role.k8s_image_swapper.id\n\n  policy = &lt;&lt;-EOF\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Sid\": \"\",\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"ecr:GetAuthorizationToken\",\n                \"ecr:DescribeRepositories\",\n                \"ecr:DescribeRegistry\"\n            ],\n            \"Resource\": \"*\"\n        },\n        {\n            \"Sid\": \"\",\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"ecr:UploadLayerPart\",\n                \"ecr:PutImage\",\n                \"ecr:ListImages\",\n                \"ecr:InitiateLayerUpload\",\n                \"ecr:GetDownloadUrlForLayer\",\n                \"ecr:CreateRepository\",\n                \"ecr:CompleteLayerUpload\",\n                \"ecr:BatchGetImage\",\n                \"ecr:BatchCheckLayerAvailability\"\n            ],\n            \"Resource\": [\n              \"arn:aws:ecr:*:${data.aws_caller_identity.current.account_id}:repository/docker.io/*\",\n              \"arn:aws:ecr:*:${data.aws_caller_identity.current.account_id}:repository/quay.io/*\"\n        ]\n        }\n    ]\n}\nEOF\n}\n\n#role for k8s-image-swapper service account\nresource \"aws_iam_role\" \"k8s_image_swapper\" {\n  name               = \"${var.cluster_name}-${var.k8s_image_swapper_name}\"\n  assume_role_policy = &lt;&lt;-EOF\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"Federated\": \"arn:aws:iam::${data.aws_caller_identity.current.account_id}:oidc-provider/${replace(var.cluster_oidc_provider, \"/https:///\", \"\")}\"\n      },\n      \"Action\": \"sts:AssumeRoleWithWebIdentity\",\n      \"Condition\": {\n        \"StringEquals\": {\n          \"${replace(var.cluster_oidc_provider, \"/https:///\", \"\")}:sub\": \"system:serviceaccount:${var.k8s_image_swapper_namespace}:${var.k8s_image_swapper_name}\"\n        }\n      }\n    }\n  ]\n}\nEOF\n}\n</code></pre> <ol> <li> <p>Use a tool like kubectx &amp; kubens for convienience.\u00a0\u21a9</p> </li> <li> IAM Policy <pre><code>{\n\"Version\": \"2012-10-17\",\n\"Statement\": [\n{\n\"Sid\": \"\",\n\"Effect\": \"Allow\",\n\"Action\": [\n\"ecr:GetAuthorizationToken\",\n\"ecr:DescribeRepositories\",\n\"ecr:DescribeRegistry\"\n],\n\"Resource\": \"*\"\n},\n{\n\"Sid\": \"\",\n\"Effect\": \"Allow\",\n\"Action\": [\n\"ecr:UploadLayerPart\",\n\"ecr:PutImage\",\n\"ecr:ListImages\",\n\"ecr:InitiateLayerUpload\",\n\"ecr:GetDownloadUrlForLayer\",\n\"ecr:CreateRepository\",\n\"ecr:CompleteLayerUpload\",\n\"ecr:BatchGetImage\",\n\"ecr:BatchCheckLayerAvailability\"\n],\n\"Resource\": \"arn:aws:ecr:*:123456789:repository/*\"\n}\n]\n}\n</code></pre> <p>Further restricting access</p> <p>The resource configuration allows access to all AWS ECR repositories within the account 123456789. Restrict this further by repository name or tag. <code>k8s-image-swapper</code> will create repositories with the source registry as prefix, e.g. <code>nginx</code> \u2192 <code>docker.io/library/nginx:latest</code>.</p> <p>\u21a9\u21a9\u21a9</p> </li> </ol>"}]}